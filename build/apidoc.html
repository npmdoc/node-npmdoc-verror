<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/davepacheco/node-verror#readme"

    >verror (v1.9.0)</a>
</h1>
<h4>richer JavaScript errors</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.verror">module verror</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.verror">
            function <span class="apidocSignatureSpan"></span>verror
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.MultiError">
            function <span class="apidocSignatureSpan">verror.</span>MultiError
            <span class="apidocSignatureSpan">(errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.SError">
            function <span class="apidocSignatureSpan">verror.</span>SError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError">
            function <span class="apidocSignatureSpan">verror.</span>VError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.WError">
            function <span class="apidocSignatureSpan">verror.</span>WError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.cause">
            function <span class="apidocSignatureSpan">verror.</span>cause
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.findCauseByName">
            function <span class="apidocSignatureSpan">verror.</span>findCauseByName
            <span class="apidocSignatureSpan">(err, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.fullStack">
            function <span class="apidocSignatureSpan">verror.</span>fullStack
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.hasCauseWithName">
            function <span class="apidocSignatureSpan">verror.</span>hasCauseWithName
            <span class="apidocSignatureSpan">(err, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.info">
            function <span class="apidocSignatureSpan">verror.</span>info
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.super_">
            function <span class="apidocSignatureSpan">verror.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">verror.</span>MultiError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">verror.</span>VError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">verror.</span>WError.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.verror.MultiError">module verror.MultiError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.MultiError.MultiError">
            function <span class="apidocSignatureSpan">verror.</span>MultiError
            <span class="apidocSignatureSpan">(errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.MultiError.super_">
            function <span class="apidocSignatureSpan">verror.MultiError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.verror.MultiError.prototype">module verror.MultiError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.MultiError.prototype.errors">
            function <span class="apidocSignatureSpan">verror.MultiError.prototype.</span>errors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">verror.MultiError.prototype.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.verror.SError">module verror.SError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.SError.SError">
            function <span class="apidocSignatureSpan">verror.</span>SError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.SError.super_">
            function <span class="apidocSignatureSpan">verror.SError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.verror.VError">module verror.VError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.VError">
            function <span class="apidocSignatureSpan">verror.</span>VError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.MultiError">
            function <span class="apidocSignatureSpan">verror.VError.</span>MultiError
            <span class="apidocSignatureSpan">(errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.SError">
            function <span class="apidocSignatureSpan">verror.VError.</span>SError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.WError">
            function <span class="apidocSignatureSpan">verror.VError.</span>WError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.cause">
            function <span class="apidocSignatureSpan">verror.VError.</span>cause
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.findCauseByName">
            function <span class="apidocSignatureSpan">verror.VError.</span>findCauseByName
            <span class="apidocSignatureSpan">(err, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.fullStack">
            function <span class="apidocSignatureSpan">verror.VError.</span>fullStack
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.hasCauseWithName">
            function <span class="apidocSignatureSpan">verror.VError.</span>hasCauseWithName
            <span class="apidocSignatureSpan">(err, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.info">
            function <span class="apidocSignatureSpan">verror.VError.</span>info
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.super_">
            function <span class="apidocSignatureSpan">verror.VError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.verror.VError.prototype">module verror.VError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.prototype.cause">
            function <span class="apidocSignatureSpan">verror.VError.prototype.</span>cause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.VError.prototype.toString">
            function <span class="apidocSignatureSpan">verror.VError.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">verror.VError.prototype.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.verror.WError">module verror.WError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.WError.WError">
            function <span class="apidocSignatureSpan">verror.</span>WError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.WError.super_">
            function <span class="apidocSignatureSpan">verror.WError.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.verror.WError.prototype">module verror.WError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.WError.prototype.cause">
            function <span class="apidocSignatureSpan">verror.WError.prototype.</span>cause
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.WError.prototype.toString">
            function <span class="apidocSignatureSpan">verror.WError.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">verror.WError.prototype.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.verror.super_">module verror.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.super_.super_">
            function <span class="apidocSignatureSpan">verror.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.verror.super_.captureStackTrace">
            function <span class="apidocSignatureSpan">verror.super_.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">verror.super_.</span>stackTraceLimit</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.verror" id="apidoc.module.verror">module verror</a></h1>


    <h2>
        <a href="#apidoc.element.verror.verror" id="apidoc.element.verror.verror">
        function <span class="apidocSignatureSpan"></span>verror
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VError()
{
	var args, obj, parsed, cause, ctor, message, k;

	args = Array.prototype.slice.call(arguments, 0);

	<span class="apidocCodeCommentSpan">/*
	 * This is a regrettable pattern, but JavaScript&#x27;s built-in Error class
	 * is defined to work this way, so we allow the constructor to be called
	 * without &#x22;new&#x22;.
	 */
</span>	if (!(this instanceof VError)) {
		obj = Object.create(VError.prototype);
		VError.apply(obj, arguments);
		return (obj);
	}

	/*
	 * For convenience and backwards compatibility, we support several
	 * different calling forms.  Normalize them here.
	 */
	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: false
	});

	/*
	 * If we&#x27;ve been given a name, apply it now.
	 */
	if (parsed.options.name) {
		mod_assertplus.string(parsed.options.name,
		    &#x27;error\&#x27;s &#x22;name&#x22; must be a string&#x27;);
		this.name = parsed.options.name;
	}

	/*
	 * For debugging, we keep track of the original short message (attached
	 * this Error particularly) separately from the complete message (which
	 * includes the messages of our cause chain).
	 */
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;

	/*
	 * If we&#x27;ve been given a cause, record a reference to it and update our
	 * message appropriately.
	 */
	cause = parsed.options.cause;
	if (cause) {
		mod_assertplus.ok(mod_isError(cause), &#x27;cause is not an Error&#x27;);
		this.jse_cause = cause;

		if (!parsed.options.skipCauseMessage) {
			message += &#x27;: &#x27; + cause.message;
		}
	}

	/*
	 * If we&#x27;ve been given an object with properties, shallow-copy that
	 * here.  We don&#x27;t want to use a deep copy in case there are non-plain
	 * objects here, but we don&#x27;t want to use the original object in case
	 * the caller modifies it later.
	 */
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}

	this.message = message;
	Error.call(this, message);

	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.MultiError" id="apidoc.element.verror.MultiError">
        function <span class="apidocSignatureSpan">verror.</span>MultiError
        <span class="apidocSignatureSpan">(errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiError(errors)
{
	mod_assertplus.array(errors, &#x27;list of errors&#x27;);
	mod_assertplus.ok(errors.length &#x3e; 0, &#x27;must be at least one error&#x27;);
	this.ase_errors = errors;

	VError.call(this, {
	    &#x27;cause&#x27;: errors[0]
	}, &#x27;first of %d error%s&#x27;, errors.length, errors.length == 1 ? &#x27;&#x27; : &#x27;s&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.SError" id="apidoc.element.verror.SError">
        function <span class="apidocSignatureSpan">verror.</span>SError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof SError)) {
		obj = Object.create(SError.prototype);
		SError.apply(obj, arguments);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: true
	});

	options = parsed.options;
	VError.call(this, options, &#x27;%s&#x27;, parsed.shortmessage);

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError" id="apidoc.element.verror.VError">
        function <span class="apidocSignatureSpan">verror.</span>VError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VError()
{
	var args, obj, parsed, cause, ctor, message, k;

	args = Array.prototype.slice.call(arguments, 0);

	<span class="apidocCodeCommentSpan">/*
	 * This is a regrettable pattern, but JavaScript&#x27;s built-in Error class
	 * is defined to work this way, so we allow the constructor to be called
	 * without &#x22;new&#x22;.
	 */
</span>	if (!(this instanceof VError)) {
		obj = Object.create(VError.prototype);
		VError.apply(obj, arguments);
		return (obj);
	}

	/*
	 * For convenience and backwards compatibility, we support several
	 * different calling forms.  Normalize them here.
	 */
	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: false
	});

	/*
	 * If we&#x27;ve been given a name, apply it now.
	 */
	if (parsed.options.name) {
		mod_assertplus.string(parsed.options.name,
		    &#x27;error\&#x27;s &#x22;name&#x22; must be a string&#x27;);
		this.name = parsed.options.name;
	}

	/*
	 * For debugging, we keep track of the original short message (attached
	 * this Error particularly) separately from the complete message (which
	 * includes the messages of our cause chain).
	 */
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;

	/*
	 * If we&#x27;ve been given a cause, record a reference to it and update our
	 * message appropriately.
	 */
	cause = parsed.options.cause;
	if (cause) {
		mod_assertplus.ok(mod_isError(cause), &#x27;cause is not an Error&#x27;);
		this.jse_cause = cause;

		if (!parsed.options.skipCauseMessage) {
			message += &#x27;: &#x27; + cause.message;
		}
	}

	/*
	 * If we&#x27;ve been given an object with properties, shallow-copy that
	 * here.  We don&#x27;t want to use a deep copy in case there are non-plain
	 * objects here, but we don&#x27;t want to use the original object in case
	 * the caller modifies it later.
	 */
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}

	this.message = message;
	Error.call(this, message);

	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.WError" id="apidoc.element.verror.WError">
        function <span class="apidocSignatureSpan">verror.</span>WError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof WError)) {
		obj = Object.create(WError.prototype);
		WError.apply(obj, args);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: false
	});

	options = parsed.options;
	options[&#x27;skipCauseMessage&#x27;] = true;
	VError.call(this, options, &#x27;%s&#x27;, parsed.shortmessage);

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.cause" id="apidoc.element.verror.cause">
        function <span class="apidocSignatureSpan">verror.</span>cause
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cause = function (err)
{
	mod_assertplus.ok(mod_isError(err), &#x27;err must be an Error&#x27;);
	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    sort: open failed: /nonexistent: No such file or directory

To match the Unixy feel, when you print out the error, just prepend the
program&#x27;s name to the VError&#x27;s `message`.  Or just call
[node-cmdutil.fail(your_verror)](https://github.com/joyent/node-cmdutil), which
does this for you.

You can get the next-level Error using `err.<span class="apidocCodeKeywordSpan">cause</span>()`:

```javascript
console.error(err2.cause().message);
```

prints:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.findCauseByName" id="apidoc.element.verror.findCauseByName">
        function <span class="apidocSignatureSpan">verror.</span>findCauseByName
        <span class="apidocSignatureSpan">(err, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findCauseByName = function (err, name)
{
	var cause;

	mod_assertplus.ok(mod_isError(err), &#x27;err must be an Error&#x27;);
	mod_assertplus.string(name, &#x27;name&#x27;);
	mod_assertplus.ok(name.length &#x3e; 0, &#x27;name cannot be empty&#x27;);

	for (cause = err; cause !== null; cause = VError.cause(cause)) {
		mod_assertplus.ok(mod_isError(cause));
		if (cause.name == name) {
			return (cause);
		}
	}

	return (null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
booleans, strings, and objects and arrays containing only other plain objects).

### `VError.fullStack(err)`

Returns a string containing the full stack trace, with all nested errors recursively
reported as `&#x27;caused by:&#x27; + err.stack`.

### `VError.<span class="apidocCodeKeywordSpan">findCauseByName</span>(err, name)`

The `findCauseByName()` function traverses the cause chain for `err`, looking
for an error whose `name` property matches the passed in `name` value. If no
match is found, `null` is returned.

If all you want is to know _whether_ there&#x27;s a cause (and you don&#x27;t care what it
is), you can use `VError.hasCauseWithName(err, name)`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.fullStack" id="apidoc.element.verror.fullStack">
        function <span class="apidocSignatureSpan">verror.</span>fullStack
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fullStack = function (err)
{
	mod_assertplus.ok(mod_isError(err), &#x27;err must be an Error&#x27;);

	var cause = VError.cause(err);

	if (cause) {
		return (err.stack + &#x27;\ncaused by: &#x27; + VError.fullStack(cause));
	}

	return (err.stack);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
These properties are intended to provide programmatically-accessible metadata
about the error.  For an error that indicates a failure to resolve a DNS name,
informational properties might include the DNS name to be resolved, or even the
list of resolvers used to resolve it.  The values of these properties should
generally be plain objects (i.e., consisting only of null, undefined, numbers,
booleans, strings, and objects and arrays containing only other plain objects).

### `VError.<span class="apidocCodeKeywordSpan">fullStack</span>(err)`

Returns a string containing the full stack trace, with all nested errors recursively
reported as `&#x27;caused by:&#x27; + err.stack`.

### `VError.findCauseByName(err, name)`

The `findCauseByName()` function traverses the cause chain for `err`, looking
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.hasCauseWithName" id="apidoc.element.verror.hasCauseWithName">
        function <span class="apidocSignatureSpan">verror.</span>hasCauseWithName
        <span class="apidocSignatureSpan">(err, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasCauseWithName = function (err, name)
{
	return (VError.findCauseByName(err, name) !== null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### `VError.findCauseByName(err, name)`

The `findCauseByName()` function traverses the cause chain for `err`, looking
for an error whose `name` property matches the passed in `name` value. If no
match is found, `null` is returned.

If all you want is to know _whether_ there&#x27;s a cause (and you don&#x27;t care what it
is), you can use `VError.<span class="apidocCodeKeywordSpan">hasCauseWithName</span>(err, name)`.

If a vanilla error or a non-VError error is passed in, then there is no cause
chain to traverse. In this scenario, the function will check the `name`
property of only `err`.

### `VError.hasCauseWithName(err, name)`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.info" id="apidoc.element.verror.info">
        function <span class="apidocSignatureSpan">verror.</span>info
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info = function (err)
{
	var rv, cause, k;

	mod_assertplus.ok(mod_isError(err), &#x27;err must be an Error&#x27;);
	cause = VError.cause(err);
	if (cause !== null) {
		rv = VError.info(cause);
	} else {
		rv = {};
	}

	if (typeof (err.jse_info) == &#x27;object&#x27; &#x26;&#x26; err.jse_info !== null) {
		for (k in err.jse_info) {
			rv[k] = err.jse_info[k];
		}
	}

	return (rv);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    name: FastServerError
    message: &#x22;server error: user &#x27;bob&#x27; is not authorized&#x22;
    cause:
        name: UnauthorizedError
        message: &#x22;user &#x27;bob&#x27; is not authorized&#x22;
        rpcUser: &#x22;bob&#x22;

When the caller uses `VError.<span class="apidocCodeKeywordSpan">info</span>()`, the information properties are collapsed
so that it looks like this:

message: &#x22;request failed: server error: user &#x27;bob&#x27; is not authorized&#x22;
rpcMsgid: &#x3c;unique identifier for this request&#x3e;
rpcMethod: GetObject
rpcUser: &#x22;bob&#x22;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.super_" id="apidoc.element.verror.super_">
        function <span class="apidocSignatureSpan">verror.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.verror.MultiError" id="apidoc.module.verror.MultiError">module verror.MultiError</a></h1>


    <h2>
        <a href="#apidoc.element.verror.MultiError.MultiError" id="apidoc.element.verror.MultiError.MultiError">
        function <span class="apidocSignatureSpan">verror.</span>MultiError
        <span class="apidocSignatureSpan">(errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiError(errors)
{
	mod_assertplus.array(errors, &#x27;list of errors&#x27;);
	mod_assertplus.ok(errors.length &#x3e; 0, &#x27;must be at least one error&#x27;);
	this.ase_errors = errors;

	VError.call(this, {
	    &#x27;cause&#x27;: errors[0]
	}, &#x27;first of %d error%s&#x27;, errors.length, errors.length == 1 ? &#x27;&#x27; : &#x27;s&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.MultiError.super_" id="apidoc.element.verror.MultiError.super_">
        function <span class="apidocSignatureSpan">verror.MultiError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VError()
{
	var args, obj, parsed, cause, ctor, message, k;

	args = Array.prototype.slice.call(arguments, 0);

	<span class="apidocCodeCommentSpan">/*
	 * This is a regrettable pattern, but JavaScript&#x27;s built-in Error class
	 * is defined to work this way, so we allow the constructor to be called
	 * without &#x22;new&#x22;.
	 */
</span>	if (!(this instanceof VError)) {
		obj = Object.create(VError.prototype);
		VError.apply(obj, arguments);
		return (obj);
	}

	/*
	 * For convenience and backwards compatibility, we support several
	 * different calling forms.  Normalize them here.
	 */
	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: false
	});

	/*
	 * If we&#x27;ve been given a name, apply it now.
	 */
	if (parsed.options.name) {
		mod_assertplus.string(parsed.options.name,
		    &#x27;error\&#x27;s &#x22;name&#x22; must be a string&#x27;);
		this.name = parsed.options.name;
	}

	/*
	 * For debugging, we keep track of the original short message (attached
	 * this Error particularly) separately from the complete message (which
	 * includes the messages of our cause chain).
	 */
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;

	/*
	 * If we&#x27;ve been given a cause, record a reference to it and update our
	 * message appropriately.
	 */
	cause = parsed.options.cause;
	if (cause) {
		mod_assertplus.ok(mod_isError(cause), &#x27;cause is not an Error&#x27;);
		this.jse_cause = cause;

		if (!parsed.options.skipCauseMessage) {
			message += &#x27;: &#x27; + cause.message;
		}
	}

	/*
	 * If we&#x27;ve been given an object with properties, shallow-copy that
	 * here.  We don&#x27;t want to use a deep copy in case there are non-plain
	 * objects here, but we don&#x27;t want to use the original object in case
	 * the caller modifies it later.
	 */
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}

	this.message = message;
	Error.call(this, message);

	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.verror.MultiError.prototype" id="apidoc.module.verror.MultiError.prototype">module verror.MultiError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.verror.MultiError.prototype.errors" id="apidoc.element.verror.MultiError.prototype.errors">
        function <span class="apidocSignatureSpan">verror.MultiError.prototype.</span>errors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function me_errors()
{
	return (this.ase_errors.slice(0));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.verror.SError" id="apidoc.module.verror.SError">module verror.SError</a></h1>


    <h2>
        <a href="#apidoc.element.verror.SError.SError" id="apidoc.element.verror.SError.SError">
        function <span class="apidocSignatureSpan">verror.</span>SError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof SError)) {
		obj = Object.create(SError.prototype);
		SError.apply(obj, arguments);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: true
	});

	options = parsed.options;
	VError.call(this, options, &#x27;%s&#x27;, parsed.shortmessage);

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.SError.super_" id="apidoc.element.verror.SError.super_">
        function <span class="apidocSignatureSpan">verror.SError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VError()
{
	var args, obj, parsed, cause, ctor, message, k;

	args = Array.prototype.slice.call(arguments, 0);

	<span class="apidocCodeCommentSpan">/*
	 * This is a regrettable pattern, but JavaScript&#x27;s built-in Error class
	 * is defined to work this way, so we allow the constructor to be called
	 * without &#x22;new&#x22;.
	 */
</span>	if (!(this instanceof VError)) {
		obj = Object.create(VError.prototype);
		VError.apply(obj, arguments);
		return (obj);
	}

	/*
	 * For convenience and backwards compatibility, we support several
	 * different calling forms.  Normalize them here.
	 */
	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: false
	});

	/*
	 * If we&#x27;ve been given a name, apply it now.
	 */
	if (parsed.options.name) {
		mod_assertplus.string(parsed.options.name,
		    &#x27;error\&#x27;s &#x22;name&#x22; must be a string&#x27;);
		this.name = parsed.options.name;
	}

	/*
	 * For debugging, we keep track of the original short message (attached
	 * this Error particularly) separately from the complete message (which
	 * includes the messages of our cause chain).
	 */
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;

	/*
	 * If we&#x27;ve been given a cause, record a reference to it and update our
	 * message appropriately.
	 */
	cause = parsed.options.cause;
	if (cause) {
		mod_assertplus.ok(mod_isError(cause), &#x27;cause is not an Error&#x27;);
		this.jse_cause = cause;

		if (!parsed.options.skipCauseMessage) {
			message += &#x27;: &#x27; + cause.message;
		}
	}

	/*
	 * If we&#x27;ve been given an object with properties, shallow-copy that
	 * here.  We don&#x27;t want to use a deep copy in case there are non-plain
	 * objects here, but we don&#x27;t want to use the original object in case
	 * the caller modifies it later.
	 */
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}

	this.message = message;
	Error.call(this, message);

	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.verror.VError" id="apidoc.module.verror.VError">module verror.VError</a></h1>


    <h2>
        <a href="#apidoc.element.verror.VError.VError" id="apidoc.element.verror.VError.VError">
        function <span class="apidocSignatureSpan">verror.</span>VError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VError()
{
	var args, obj, parsed, cause, ctor, message, k;

	args = Array.prototype.slice.call(arguments, 0);

	<span class="apidocCodeCommentSpan">/*
	 * This is a regrettable pattern, but JavaScript&#x27;s built-in Error class
	 * is defined to work this way, so we allow the constructor to be called
	 * without &#x22;new&#x22;.
	 */
</span>	if (!(this instanceof VError)) {
		obj = Object.create(VError.prototype);
		VError.apply(obj, arguments);
		return (obj);
	}

	/*
	 * For convenience and backwards compatibility, we support several
	 * different calling forms.  Normalize them here.
	 */
	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: false
	});

	/*
	 * If we&#x27;ve been given a name, apply it now.
	 */
	if (parsed.options.name) {
		mod_assertplus.string(parsed.options.name,
		    &#x27;error\&#x27;s &#x22;name&#x22; must be a string&#x27;);
		this.name = parsed.options.name;
	}

	/*
	 * For debugging, we keep track of the original short message (attached
	 * this Error particularly) separately from the complete message (which
	 * includes the messages of our cause chain).
	 */
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;

	/*
	 * If we&#x27;ve been given a cause, record a reference to it and update our
	 * message appropriately.
	 */
	cause = parsed.options.cause;
	if (cause) {
		mod_assertplus.ok(mod_isError(cause), &#x27;cause is not an Error&#x27;);
		this.jse_cause = cause;

		if (!parsed.options.skipCauseMessage) {
			message += &#x27;: &#x27; + cause.message;
		}
	}

	/*
	 * If we&#x27;ve been given an object with properties, shallow-copy that
	 * here.  We don&#x27;t want to use a deep copy in case there are non-plain
	 * objects here, but we don&#x27;t want to use the original object in case
	 * the caller modifies it later.
	 */
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}

	this.message = message;
	Error.call(this, message);

	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError.MultiError" id="apidoc.element.verror.VError.MultiError">
        function <span class="apidocSignatureSpan">verror.VError.</span>MultiError
        <span class="apidocSignatureSpan">(errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiError(errors)
{
	mod_assertplus.array(errors, &#x27;list of errors&#x27;);
	mod_assertplus.ok(errors.length &#x3e; 0, &#x27;must be at least one error&#x27;);
	this.ase_errors = errors;

	VError.call(this, {
	    &#x27;cause&#x27;: errors[0]
	}, &#x27;first of %d error%s&#x27;, errors.length, errors.length == 1 ? &#x27;&#x27; : &#x27;s&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError.SError" id="apidoc.element.verror.VError.SError">
        function <span class="apidocSignatureSpan">verror.VError.</span>SError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof SError)) {
		obj = Object.create(SError.prototype);
		SError.apply(obj, arguments);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: true
	});

	options = parsed.options;
	VError.call(this, options, &#x27;%s&#x27;, parsed.shortmessage);

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError.WError" id="apidoc.element.verror.VError.WError">
        function <span class="apidocSignatureSpan">verror.VError.</span>WError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof WError)) {
		obj = Object.create(WError.prototype);
		WError.apply(obj, args);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: false
	});

	options = parsed.options;
	options[&#x27;skipCauseMessage&#x27;] = true;
	VError.call(this, options, &#x27;%s&#x27;, parsed.shortmessage);

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError.cause" id="apidoc.element.verror.VError.cause">
        function <span class="apidocSignatureSpan">verror.VError.</span>cause
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cause = function (err)
{
	mod_assertplus.ok(mod_isError(err), &#x27;err must be an Error&#x27;);
	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    sort: open failed: /nonexistent: No such file or directory

To match the Unixy feel, when you print out the error, just prepend the
program&#x27;s name to the VError&#x27;s `message`.  Or just call
[node-cmdutil.fail(your_verror)](https://github.com/joyent/node-cmdutil), which
does this for you.

You can get the next-level Error using `err.<span class="apidocCodeKeywordSpan">cause</span>()`:

```javascript
console.error(err2.cause().message);
```

prints:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError.findCauseByName" id="apidoc.element.verror.VError.findCauseByName">
        function <span class="apidocSignatureSpan">verror.VError.</span>findCauseByName
        <span class="apidocSignatureSpan">(err, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findCauseByName = function (err, name)
{
	var cause;

	mod_assertplus.ok(mod_isError(err), &#x27;err must be an Error&#x27;);
	mod_assertplus.string(name, &#x27;name&#x27;);
	mod_assertplus.ok(name.length &#x3e; 0, &#x27;name cannot be empty&#x27;);

	for (cause = err; cause !== null; cause = VError.cause(cause)) {
		mod_assertplus.ok(mod_isError(cause));
		if (cause.name == name) {
			return (cause);
		}
	}

	return (null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
booleans, strings, and objects and arrays containing only other plain objects).

### `VError.fullStack(err)`

Returns a string containing the full stack trace, with all nested errors recursively
reported as `&#x27;caused by:&#x27; + err.stack`.

### `VError.<span class="apidocCodeKeywordSpan">findCauseByName</span>(err, name)`

The `findCauseByName()` function traverses the cause chain for `err`, looking
for an error whose `name` property matches the passed in `name` value. If no
match is found, `null` is returned.

If all you want is to know _whether_ there&#x27;s a cause (and you don&#x27;t care what it
is), you can use `VError.hasCauseWithName(err, name)`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError.fullStack" id="apidoc.element.verror.VError.fullStack">
        function <span class="apidocSignatureSpan">verror.VError.</span>fullStack
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fullStack = function (err)
{
	mod_assertplus.ok(mod_isError(err), &#x27;err must be an Error&#x27;);

	var cause = VError.cause(err);

	if (cause) {
		return (err.stack + &#x27;\ncaused by: &#x27; + VError.fullStack(cause));
	}

	return (err.stack);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
These properties are intended to provide programmatically-accessible metadata
about the error.  For an error that indicates a failure to resolve a DNS name,
informational properties might include the DNS name to be resolved, or even the
list of resolvers used to resolve it.  The values of these properties should
generally be plain objects (i.e., consisting only of null, undefined, numbers,
booleans, strings, and objects and arrays containing only other plain objects).

### `VError.<span class="apidocCodeKeywordSpan">fullStack</span>(err)`

Returns a string containing the full stack trace, with all nested errors recursively
reported as `&#x27;caused by:&#x27; + err.stack`.

### `VError.findCauseByName(err, name)`

The `findCauseByName()` function traverses the cause chain for `err`, looking
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError.hasCauseWithName" id="apidoc.element.verror.VError.hasCauseWithName">
        function <span class="apidocSignatureSpan">verror.VError.</span>hasCauseWithName
        <span class="apidocSignatureSpan">(err, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasCauseWithName = function (err, name)
{
	return (VError.findCauseByName(err, name) !== null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### `VError.findCauseByName(err, name)`

The `findCauseByName()` function traverses the cause chain for `err`, looking
for an error whose `name` property matches the passed in `name` value. If no
match is found, `null` is returned.

If all you want is to know _whether_ there&#x27;s a cause (and you don&#x27;t care what it
is), you can use `VError.<span class="apidocCodeKeywordSpan">hasCauseWithName</span>(err, name)`.

If a vanilla error or a non-VError error is passed in, then there is no cause
chain to traverse. In this scenario, the function will check the `name`
property of only `err`.

### `VError.hasCauseWithName(err, name)`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError.info" id="apidoc.element.verror.VError.info">
        function <span class="apidocSignatureSpan">verror.VError.</span>info
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info = function (err)
{
	var rv, cause, k;

	mod_assertplus.ok(mod_isError(err), &#x27;err must be an Error&#x27;);
	cause = VError.cause(err);
	if (cause !== null) {
		rv = VError.info(cause);
	} else {
		rv = {};
	}

	if (typeof (err.jse_info) == &#x27;object&#x27; &#x26;&#x26; err.jse_info !== null) {
		for (k in err.jse_info) {
			rv[k] = err.jse_info[k];
		}
	}

	return (rv);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    name: FastServerError
    message: &#x22;server error: user &#x27;bob&#x27; is not authorized&#x22;
    cause:
        name: UnauthorizedError
        message: &#x22;user &#x27;bob&#x27; is not authorized&#x22;
        rpcUser: &#x22;bob&#x22;

When the caller uses `VError.<span class="apidocCodeKeywordSpan">info</span>()`, the information properties are collapsed
so that it looks like this:

message: &#x22;request failed: server error: user &#x27;bob&#x27; is not authorized&#x22;
rpcMsgid: &#x3c;unique identifier for this request&#x3e;
rpcMethod: GetObject
rpcUser: &#x22;bob&#x22;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError.super_" id="apidoc.element.verror.VError.super_">
        function <span class="apidocSignatureSpan">verror.VError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.verror.VError.prototype" id="apidoc.module.verror.VError.prototype">module verror.VError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.verror.VError.prototype.cause" id="apidoc.element.verror.VError.prototype.cause">
        function <span class="apidocSignatureSpan">verror.VError.prototype.</span>cause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ve_cause()
{
	var cause = VError.cause(this);
	return (cause === null ? undefined : cause);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    sort: open failed: /nonexistent: No such file or directory

To match the Unixy feel, when you print out the error, just prepend the
program&#x27;s name to the VError&#x27;s `message`.  Or just call
[node-cmdutil.fail(your_verror)](https://github.com/joyent/node-cmdutil), which
does this for you.

You can get the next-level Error using `err.<span class="apidocCodeKeywordSpan">cause</span>()`:

```javascript
console.error(err2.cause().message);
```

prints:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.VError.prototype.toString" id="apidoc.element.verror.VError.prototype.toString">
        function <span class="apidocSignatureSpan">verror.VError.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ve_toString()
{
	var str = (this.hasOwnProperty(&#x27;name&#x27;) &#x26;&#x26; this.name ||
		this.constructor.name || this.constructor.prototype.name);
	if (this.message)
		str += &#x27;: &#x27; + this.message;

	return (str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.verror.WError" id="apidoc.module.verror.WError">module verror.WError</a></h1>


    <h2>
        <a href="#apidoc.element.verror.WError.WError" id="apidoc.element.verror.WError.WError">
        function <span class="apidocSignatureSpan">verror.</span>WError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof WError)) {
		obj = Object.create(WError.prototype);
		WError.apply(obj, args);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: false
	});

	options = parsed.options;
	options[&#x27;skipCauseMessage&#x27;] = true;
	VError.call(this, options, &#x27;%s&#x27;, parsed.shortmessage);

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.WError.super_" id="apidoc.element.verror.WError.super_">
        function <span class="apidocSignatureSpan">verror.WError.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VError()
{
	var args, obj, parsed, cause, ctor, message, k;

	args = Array.prototype.slice.call(arguments, 0);

	<span class="apidocCodeCommentSpan">/*
	 * This is a regrettable pattern, but JavaScript&#x27;s built-in Error class
	 * is defined to work this way, so we allow the constructor to be called
	 * without &#x22;new&#x22;.
	 */
</span>	if (!(this instanceof VError)) {
		obj = Object.create(VError.prototype);
		VError.apply(obj, arguments);
		return (obj);
	}

	/*
	 * For convenience and backwards compatibility, we support several
	 * different calling forms.  Normalize them here.
	 */
	parsed = parseConstructorArguments({
	    &#x27;argv&#x27;: args,
	    &#x27;strict&#x27;: false
	});

	/*
	 * If we&#x27;ve been given a name, apply it now.
	 */
	if (parsed.options.name) {
		mod_assertplus.string(parsed.options.name,
		    &#x27;error\&#x27;s &#x22;name&#x22; must be a string&#x27;);
		this.name = parsed.options.name;
	}

	/*
	 * For debugging, we keep track of the original short message (attached
	 * this Error particularly) separately from the complete message (which
	 * includes the messages of our cause chain).
	 */
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;

	/*
	 * If we&#x27;ve been given a cause, record a reference to it and update our
	 * message appropriately.
	 */
	cause = parsed.options.cause;
	if (cause) {
		mod_assertplus.ok(mod_isError(cause), &#x27;cause is not an Error&#x27;);
		this.jse_cause = cause;

		if (!parsed.options.skipCauseMessage) {
			message += &#x27;: &#x27; + cause.message;
		}
	}

	/*
	 * If we&#x27;ve been given an object with properties, shallow-copy that
	 * here.  We don&#x27;t want to use a deep copy in case there are non-plain
	 * objects here, but we don&#x27;t want to use the original object in case
	 * the caller modifies it later.
	 */
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}

	this.message = message;
	Error.call(this, message);

	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}

	return (this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.verror.WError.prototype" id="apidoc.module.verror.WError.prototype">module verror.WError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.verror.WError.prototype.cause" id="apidoc.element.verror.WError.prototype.cause">
        function <span class="apidocSignatureSpan">verror.WError.prototype.</span>cause
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function we_cause(c)
{
	if (mod_isError(c))
		this.jse_cause = c;

	return (this.jse_cause);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    sort: open failed: /nonexistent: No such file or directory

To match the Unixy feel, when you print out the error, just prepend the
program&#x27;s name to the VError&#x27;s `message`.  Or just call
[node-cmdutil.fail(your_verror)](https://github.com/joyent/node-cmdutil), which
does this for you.

You can get the next-level Error using `err.<span class="apidocCodeKeywordSpan">cause</span>()`:

```javascript
console.error(err2.cause().message);
```

prints:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.WError.prototype.toString" id="apidoc.element.verror.WError.prototype.toString">
        function <span class="apidocSignatureSpan">verror.WError.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function we_toString()
{
	var str = (this.hasOwnProperty(&#x27;name&#x27;) &#x26;&#x26; this.name ||
		this.constructor.name || this.constructor.prototype.name);
	if (this.message)
		str += &#x27;: &#x27; + this.message;
	if (this.jse_cause &#x26;&#x26; this.jse_cause.message)
		str += &#x27;; caused by &#x27; + this.jse_cause.toString();

	return (str);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.verror.super_" id="apidoc.module.verror.super_">module verror.super_</a></h1>


    <h2>
        <a href="#apidoc.element.verror.super_.super_" id="apidoc.element.verror.super_.super_">
        function <span class="apidocSignatureSpan">verror.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.verror.super_.captureStackTrace" id="apidoc.element.verror.super_.captureStackTrace">
        function <span class="apidocSignatureSpan">verror.super_.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
